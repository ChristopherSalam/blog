<!DOCTYPE html>
<html>
<link href='https://fonts.googleapis.com/css?family=Megrim' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Montserrat+Alternates' rel='stylesheet' type='text/css'>
  <head>
    <title>trees – Christopher Salam – thoughts on software and engineering</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="True to my nature, if you look closely I&#39;m hugging that tree there.
" />
    <meta property="og:description" content="True to my nature, if you look closely I&#39;m hugging that tree there.
" />
    
    <meta name="author" content="Christopher Salam" />

    
    <meta property="og:title" content="trees" />
    <meta property="twitter:title" content="trees" />
    
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Christopher Salam - thoughts on software and engineering" href="/feed.xml" />
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src='chrissalam.jpg' /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Christopher Salam</a></h1>
            <p class="site-description">thoughts on software and engineering</p>
          </div>

          <nav>
            <!--<a href="/">Posts</a>-->
            <a href="/tags">:Topic</a>
<!--             <a href="http://christophersalam.github.io">About</a> -->
            <a href="/about">About</a>
            <a href="http://chrissalam.com/slideshow" target="_blank">Slideshow</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1 class="center-align">trees</h1>
  <div class="center-align"><div class="post-tags">
  Tags:
  
    
  
  
  <a href="/tags/#javascript">javascript</a>,
  
  <a href="/tags/#data structures">data structures</a>
  
</div></div>

  <div class="date">
    Written on August 31, 2015
  </div>

  <div class="entry">
    <p>True to my nature, if you look closely I&#39;m hugging that tree there.</p>

<p>Here&#39;s my little hug to you, console users: I&#39;ve learned after doing data transforms in the console that you can save the data object or array as a global variable and then to copy the temporary variable.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="cm">/*in console*/</span>
<span class="nx">Data</span> <span class="nb">Object</span> <span class="o">=</span> <span class="p">{...};</span>
            <span class="c1">// right click on the edge of the Object</span>
            <span class="c1">// store as a temporary variable</span>
            <span class="c1">// creates &#39;temp1&#39;</span>
<span class="nx">copy</span><span class="p">(</span><span class="nx">temp1</span><span class="p">)</span> <span class="c1">// and then run this command</span>
            <span class="c1">// to make this is available for</span>
            <span class="c1">// pasting in text editor.</span>
</code></pre></div>
<p>But this post is mostly about solving trees. which seems to be a very big obsession with the computer science interviewers. I&#39;ll try my best to talk myself into understanding trees, breath first search, depth first search, and binary trees.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">//Prototypal instantiation</span>
<span class="kd">function</span> <span class="nx">Node</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//made alternatively by using &#39;new&#39;</span>
  <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">Node</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
  <span class="nx">obj</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="nx">obj</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="nx">obj</span><span class="p">.</span><span class="nx">children</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="c1">//made alternatively by using &#39;new&#39;</span>
  <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">Tree</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//made alternatively by using &#39;new&#39;</span>
   <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">Tree</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">_root</span> <span class="o">=</span>  <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="c1">//made alternatively by using &#39;new&#39;</span>
   <span class="k">return</span> <span class="nx">obj</span>
<span class="p">};</span>
</code></pre></div>
<p>I&#39;m going to focus on psuedo-classical just because it&#39;s a bit less text, but prototypal shows what&#39;s going on under the hood. Also, it would allow us to not use the new keyword, which creates the two lines I&#39;ve indicated in comments.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">//Psuedo-classical instantiation</span>
<span class="kd">function</span> <span class="nx">Node</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">children</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">Tree</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_root</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>
<p>One quick and dirty way to add a child was this I wrote immediately. Also does anyone else hate the mixed metaphor or tree, leaves, children, and parents?</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">Tree</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">addChild</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">Tree</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
<span class="p">};</span>
</code></pre></div>
<p>Which works! For sure. The problem with this script is that it&#39;s not very elegant in that you have to nest adding children outside the the bast root.</p>

<p>For example:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">tree</span> <span class="o">=</span> <span class="nx">Tree</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="nx">tree</span><span class="p">.</span><span class="nx">addChild</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">tree</span><span class="p">.</span><span class="nx">addChild</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</code></pre></div>
<p>Which works but what if you wanted to into the next level of the tree?</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">tree</span> <span class="o">=</span> <span class="nx">Tree</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="nx">tree</span><span class="p">.</span><span class="nx">addChild</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">tree</span><span class="p">.</span><span class="nx">addChild</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="nx">tree</span><span class="p">.</span><span class="nx">child</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">addChild</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">tree</span><span class="p">.</span><span class="nx">child</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">addChild</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</code></pre></div>
<p>Which we can all agree, isn&#39;t great. There needs to be some way to add things to values at a certain spot. Additionally, their needs to be a way to separate adding things as a child, and adding as a sibling.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">Tree</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">addSibling</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">Tree</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
<span class="p">};</span>
</code></pre></div>
<p>This is getting complicated as hell. Why does a tree have siblings or children?</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">Tree</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">atValue</span><span class="p">,</span> <span class="nx">BFDF</span><span class="p">)</span> <span class="p">{</span>
 <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Tree</span><span class="p">(</span><span class="nx">value</span><span class="p">),</span>
   <span class="nx">parent</span> <span class="o">=</span> <span class="kc">null</span><span class="p">,</span>
   <span class="nx">callback</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span> <span class="o">===</span> <span class="nx">atValue</span><span class="p">)</span> <span class="p">{</span>
       <span class="nx">parent</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span>
     <span class="p">}</span>
   <span class="p">};</span>
 <span class="k">this</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="nx">callback</span><span class="p">,</span> <span class="nx">BFDF</span><span class="p">);</span>
 <span class="k">if</span> <span class="p">(</span><span class="nx">parent</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">parent</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
   <span class="nx">child</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">;</span>
 <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<!--

// Tree.prototype.DFcontains = function (value) {
//   if (this.value === value) {
//     return true;
//   } else if (this.children !== null) {
//     var result = false, i;
//     for (i = 0; result === false && i < this.children.length; i++) {
//       result = this.children[i].contains(value);
//     }
//   }
//   return result;
// };


Tree.prototype.DFtraverse = function(process) {
   process.call(this, this.value);
   var i;
   for (i = 0; i < this.children.length; i++) {
     this.children[i].DFtraverse(process);
   }
}

Tree.prototype.traverseDF = function(callback) {

   // this is a recurse and immediately-invoking function
   (function recurse(currentNode) {
       // step 2
       for (var i = 0, length = currentNode.children.length; i < length; i++) {
           // step 3
           recurse(currentNode.children[i]);
       }

       // step 4
       callback(currentNode);

       // step 1
   })(this._root);

};

Tree.prototype.BFtraverse = function(process) {
 var queue = [this],
 current = queue.shift();
   while (current) {
     for (var i = 0; i < current.children.length; i++) {
       queue.push(current.children[i]);
     }
     process.call(current, current.value);
     current = queue.shift();
   }
}

Tree.prototype.traverseBF = function(callback) {
   var queue = [this._root];

   currentTree = queue.shift();

   while(currentTree){
       for (var i = 0, length = currentTree.children.length; i < length; i++) {
           queue.push(currentTree.children[i]);
       }

       callback(currentTree);
       currentTree = queue.shift();
   }
};

Tree.prototype.contains = function(callback, traversal) {
   traversal.call(this, callback);
};

Tree.prototype.size = function() {
 var size = 0;
 this.traverseDF(function(){
   size++;
 })
 return size;
}

Tree.prototype.add = function(value, atValue, BFDF) {
 var child = new Tree(value),
   parent = null,
   callback = function(node) {
     if (node.value === atValue) {
       parent = node;
     }
   };
 this.contains(callback, BFDF);
 if (parent) {
   parent.children.push(child);
   child.parent = parent;
 }
}

Tree.prototype.add = function(data, toData, traversal) {
   var child = new Node(data),
       parent = null,
       callback = function(node) {
           if (node.data === toData) {
               parent = node;
           }
       };

   this.contains(callback, traversal);

   if (parent) {
       parent.children.push(child);
       child.parent = parent;
   } else {
       throw new Error('Cannot add node to a non-existent parent.');
   }
};

Tree.prototype.remove = function(data, fromData, traversal) {

function findIndex(arr, data) {
   var index;

   for (var i = 0; i < arr.length; i++) {
       if (arr[i].data === data) {
           index = i;
       }
   }

   return index;
}

   var tree = this,
       parent = null,
       childToRemove = null,
       index;

   var callback = function(node) {
       if (node.data === fromData) {
           parent = node;
       }
   };

   this.contains(callback, traversal);

   if (parent) {
       index = findIndex(parent.children, data);

       if (index === undefined) {
           throw new Error('Node to remove does not exist.');
       } else {
           childToRemove = parent.children.splice(index, 1);
       }
   } else {
       throw new Error('Parent does not exist.');
   }

   return childToRemove;
};

var tree = new Tree(0);
tree.add(1, 0, tree.traverseDF);
tree.add(2, 0, tree.traverseDF);
// tree.addChild(1);
// tree.addChild(2);
// tree.children[0].addChild(3);
tree.add(3, 1, tree.traverseDF);
// tree.add(3,1,tree.BFtraverse);
// tree.children[0].children[0].addChild(4);
tree.add(4, 3, tree.traverseDF);
tree.add(5, 2, tree.traverseBF);
tree.remove(5, 2, tree.traverseBF);
console.log(tree);
// tree.children[1].children[0].addChild(7);
// console.log(tree.contains(console.log,tree.DFtraverse)); // yields 'true'
// console.log(tree.contains(0)); // yields 'true'
// console.log(tree.contains(1)); // yields 'true'
// console.log(tree.contains(4)); // yields 'false'
// console.log("Depth");
// tree.DFtraverse(console.log);
// console.log("Breadth");
// tree.BFtraverse(console.log);
console.log(tree.size());-->

<!--
Tonight, I watched Cassandra's talk on functional programming, and I got pretty excited about currying, composing, and piping functions. I wanted to live code some practical examples, as I must admit it took seeing this several times for me to really wrap my head around this topic and I hope this helps!

I would recommend going to Ramda.js's website and pulling up a console there. Another option would be to npm install ramda and try these functions there. If you use sublime and do not have a JS build system, try this link from my classmate <a href="http://jdlawrence.github.io/javascript/closures/2015/08/03/console-inside-sublime-text.html">Jamil</a>. You can also grab it from CDN via

```html
<script src="//cdnjs.cloudflare.com/ajax/libs/ramda/0.17.1/ramda.min.js"></script>
```
 Currying is a transformation you can do to allow functions to take their some of their arguments at different times. Currying lets us partially fill the functions and keep them in position for later.

```javascript
function area(height, width) { return height * width; }
var curryArea = R.curry(area);

curryArea(2);    // [function]
curryArea(2)(5); // 10

```
Why is this useful?

```javascript
function that invokes
var lines = R.invoker(1, 'split')('/n');
var split = R.split('/n');
```
var getItems = R.compose(
  R.filter(R.propEq('eventType',"ITEM_DESTROYED")),
  R.flatten,
  R.map(R.prop('events'))
)

<a href="http://alicekamada.github.io/" >"Pointfree Code is code that never refers to the code it handles:
it focuses on the logic, easier to reason about, and never have to wonder about the state."</a>
-->

<!-- Anyways, we had a toy problem earlier in the program that asked us to write the functions for piping and composing functions. A pipe function asked us to create a function such that

```javascript
var newfunc =  R.pipe(func1, func2, func3)
```

where the newfunc(args_provided_to_function_one) =  -->

  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          
<a href="mailto:christopher.salam@gmail.com"><i class="svg-icon email"></i></a>
<a href="https://www.facebook.com/mrsalam@ucdavis.edu"><i class="svg-icon facebook"></i></a>

<a href="https://github.com/ChristopherSalam"><i class="svg-icon github"></i></a>

<a href="https://www.linkedin.com/in/christophersalam"><i class="svg-icon linkedin"></i></a>






        </footer>
      </div>
    </div>
    

  </body>
</html>
