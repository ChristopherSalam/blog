<!DOCTYPE html>
<html>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
<link rel="stylesheet" href="http://chrissalam.com/languages/font-mfizz.css">
<link href='https://fonts.googleapis.com/css?family=Megrim' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Montserrat+Alternates' rel='stylesheet' type='text/css'>
  <head>
    <title>matrix paths – Christopher Salam – thoughts on software and engineering</title>
        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>
    
    <meta name="description" content="Christopher Salam This is part 2 of 2 of the Path Problem series.
" />
    <meta property="og:description" content="This is part 2 of 2 of the Path Problem series.
" />
    
    <meta name="author" content="Christopher Salam" />
    
    <meta property="og:title" content="matrix paths" />
    <meta property="twitter:title" content="matrix paths" />
    

    <link rel="icon" type="image/ico" href="chrissalam.jpg">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Christopher Salam - thoughts on software and engineering" href="/feed.xml" />
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src='chrissalam.jpg' /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Christopher Salam</a></h1>
            <p class="site-description">thoughts on software and engineering</p>
          </div>

          <nav>
            <!--<a href="/">Posts</a>-->
            <a href="/tags">:sub</a>
<!--             <a href="http://christophersalam.github.io">About</a> -->
            <a href="/about">About Me</a>
            <a href="http://christophersalam.github.io" target="_blank"><i class="fa fa-music"></i></a>
            <a href="http://vintagebicycles.info" target="_blank"><i class="fa fa-bicycle"></i></a>
            <a href="http://chrissalam.github.io" target="_blank"><i class="fa fa-file-text"></i></a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1 class="center-align">matrix paths</h1>
  <div class="center-align"><div class="post-tags">
  Tags:
  
    
  
  
  <a href="/tags/#ds">ds</a>,
  
  <a href="/tags/#javascript">javascript</a>
  
</div></div>

  <div class="date">
    Written on November 12, 2015
  </div>

  <div class="entry">
    <p>This is part 2 of 2 of the Path Problem series.</p>

<p><strong><a href="/array-paths" title="Array Paths">Part 1 - Array Paths</a></strong> | Part 2</p>

<p>I&#39;ve been beginning to see a pattern to many problems, which I&#39;m going to term path problems. One major type of problems involves the traversal across a matrix.  The goals here are here to determine how to store information and use arguments recursively (or iteratively) to carry information you need to the next step.</p>

<h3>The Fishing Trip Problem</h3>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="cm">/*====================================||</span>
<span class="cm">|| Fishing Trip                       ||</span>
<span class="cm">||                                    ||</span>
<span class="cm">|| In this problem you will travel    ||</span>
<span class="cm">|| through all possible paths through ||</span>
<span class="cm">|| a lake collecting fish. You must   ||</span>
<span class="cm">|| start at the top left corner and   ||</span>
<span class="cm">|| go only one space at a time either ||</span>
<span class="cm">|| right or down until you reach the  ||</span>
<span class="cm">|| right bottom corner [2,2] for a    ||</span>
<span class="cm">|| 3 x 3 matrix. Keep track of the    ||</span>
<span class="cm">|| total amount of fish each path can ||</span>
<span class="cm">|| provide for you and report the     ||</span>
<span class="cm">|| maximum catch                      ||</span>
<span class="cm">||====================================*/</span>

<span class="kd">var</span> <span class="nx">pond</span> <span class="o">=</span>
<span class="p">[</span>
  <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">3</span> <span class="p">],</span>
  <span class="p">[</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span> <span class="p">],</span>
  <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span>  <span class="mi">2</span> <span class="p">]</span>
<span class="p">];</span>
</code></pre></div>
<p>Whoa... right? I was similarly stammering on what to do next when I first saw it. We&#39;ve discussed the pieces above. These fit a lot of patterns we see in games, or maybe this could serve as an example for path optimization for trip runners.</p>

<p>We need a running total on each route, addition steps, options to travel in both directions, and routes that fail when we cross boundaries. Let&#39;s get to it! Here&#39;s a diagram.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">zone</span> <span class="o">=</span>
  <span class="p">[</span>   <span class="p">[</span> <span class="nx">start</span><span class="p">,</span> <span class="err">#</span><span class="p">,</span>  <span class="err">#</span>   <span class="p">]</span>
      <span class="p">[</span> <span class="err">#</span><span class="p">,</span>     <span class="err">#</span><span class="p">,</span>  <span class="err">#</span>   <span class="p">]</span>
      <span class="p">[</span> <span class="err">#</span><span class="p">,</span>     <span class="err">#</span><span class="p">,</span>  <span class="nx">end</span> <span class="p">]</span>   <span class="p">]</span>
</code></pre></div>
<p>Following a diagram like this, work within all possible paths from start to end (there are six in this case)</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">[</span> <span class="p">[</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span>  <span class="nx">_</span>   <span class="p">]</span>    <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span>  <span class="p">[</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="err">#</span>   <span class="p">]</span>
      <span class="p">[</span> <span class="err">#</span><span class="p">,</span>     <span class="err">#</span><span class="p">,</span>  <span class="nx">_</span>   <span class="p">]</span>           <span class="p">[</span> <span class="err">#</span><span class="p">,</span>     <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span>   <span class="p">]</span>
      <span class="p">[</span> <span class="err">#</span><span class="p">,</span>     <span class="err">#</span><span class="p">,</span>  <span class="nx">end</span> <span class="p">]</span> <span class="p">]</span>         <span class="p">[</span> <span class="err">#</span><span class="p">,</span>     <span class="err">#</span><span class="p">,</span> <span class="nx">end</span> <span class="p">]</span> <span class="p">]</span>

<span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span> <span class="p">[</span> <span class="nx">start</span><span class="p">,</span> <span class="err">#</span><span class="p">,</span>  <span class="err">#</span>   <span class="p">]</span>    <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span>  <span class="p">[</span> <span class="nx">start</span><span class="p">,</span><span class="nx">_</span><span class="p">,</span> <span class="err">#</span>    <span class="p">]</span>
      <span class="p">[</span> <span class="nx">_</span><span class="p">,</span>    <span class="nx">_</span><span class="p">,</span>   <span class="err">#</span>   <span class="p">]</span>           <span class="p">[</span> <span class="err">#</span><span class="p">,</span>    <span class="nx">_</span><span class="p">,</span> <span class="err">#</span>    <span class="p">]</span>
      <span class="p">[</span> <span class="err">#</span><span class="p">,</span>    <span class="nx">_</span><span class="p">,</span> <span class="nx">end</span>   <span class="p">]</span> <span class="p">]</span>         <span class="p">[</span> <span class="err">#</span><span class="p">,</span>    <span class="nx">_</span><span class="p">,</span> <span class="nx">end</span>  <span class="p">]</span> <span class="p">]</span>

<span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">[</span> <span class="p">[</span> <span class="nx">start</span><span class="p">,</span> <span class="err">#</span><span class="p">,</span> <span class="err">#</span>    <span class="p">]</span>    <span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">[</span>  <span class="p">[</span> <span class="nx">start</span><span class="p">,</span> <span class="err">#</span><span class="p">,</span> <span class="err">#</span>   <span class="p">]</span>
      <span class="p">[</span> <span class="nx">_</span><span class="p">,</span>     <span class="err">#</span><span class="p">,</span> <span class="err">#</span>    <span class="p">]</span>           <span class="p">[</span> <span class="nx">_</span><span class="p">,</span>     <span class="nx">_</span><span class="p">,</span> <span class="err">#</span>   <span class="p">]</span>
      <span class="p">[</span> <span class="nx">_</span><span class="p">,</span>     <span class="nx">_</span><span class="p">,</span> <span class="nx">end</span>  <span class="p">]</span> <span class="p">]</span>         <span class="p">[</span> <span class="err">#</span><span class="p">,</span>     <span class="nx">_</span><span class="p">,</span> <span class="nx">end</span> <span class="p">]</span> <span class="p">]</span>
</code></pre></div>
<p>Another way to think about this is in terms of combinatorics, which I would not even consider, had I not played many years of board games versus <a href="http://inventingsituations.net/">Tom</a> and <a href="https://dailycampusarchive.wordpress.com/2015/02/20/last-lecture-beloved-math-professor-patrick-dragon/">Patrick</a>, both PhDs in this tricky math form. This path problem reduces to a (2(n-1)!)/(n-1)!(n-1)! problem for an n x n, and a problem with movement in all compass directions (NWSE) is simply double that. <a href="http://joaoff.com/2008/01/20/a-square-grid-path-problem/"> Here&#39;s a post on that kind of solution.</a> You can use combinatorics to set a for loop for an iterative solution but it&#39;s often easier and more to to build a recursive solution and have it determine the number of combinations needed.</p>

<p>Another way to look at this set of decisions is a tree. We don&#39;t need to use the tree data structure, just absorb that this solution can be done recursively (or iteratively if you know the combinations ahead of time).</p>

<p><img src="treeChoice.png" alt="visual of decisions"></p>

<p>You get the drift.</p>

<p>In my mind these diagrams <strong>aren&#39;t</strong> the most accurate way of thinking about <strong>how computers solve</strong> this problem. These show the valid results, and if you want to create an algorithm to this this will be a little more overhead. Instead, we are going to write one that expands in two directions and fails once it finds that there is no matrix value.</p>

<p>The algorithm needs to fail, or return an empty value, when it goes out of bounds. The boundary conditions we can use are natural for the matrix, we can ask it if values exist there, such as:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Boolean</span><span class="p">(</span><span class="nx">zone</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">--&gt;</span> <span class="kc">true</span>
<span class="nb">Boolean</span><span class="p">(</span><span class="nx">zone</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">])</span> <span class="o">--&gt;</span> <span class="kc">undefined</span>
</code></pre></div>
<p>And where ever our boundary conditions fail we can just &#39;return 0;&#39; or &#39;return;&#39; depending on what we are trying to keep track of. The other important piece is that while we travel each path, we need to pass information on as arguments to the recursive function, often without modifying the functions in place to preserve what we are interested in. For example:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">recursive</span><span class="p">(</span><span class="nx">stuff</span><span class="p">,</span> <span class="nx">moreStuff</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">stuff</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">moreStuff</span> <span class="o">=</span> <span class="nx">moreStruff</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">recursive</span><span class="p">(</span><span class="nx">stuff</span><span class="p">,</span> <span class="nx">moreStuff</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>versus</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">recursive</span><span class="p">(</span><span class="nx">stuff</span><span class="p">,</span> <span class="nx">moreStuff</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">do</span> <span class="nx">tasks</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">recursive</span><span class="p">(</span><span class="nx">stuff</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">moreStuff</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p>And decisions at to keep data around in this way will either help you keeping running totals or deal with a specific value at each stop. Let&#39;s start our fishing problem.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">fishingTrip</span><span class="p">(</span><span class="nx">matrix</span><span class="p">)</span> <span class="p">{</span>

<span class="c1">//boundary variables.</span>
<span class="c1">//another approach is</span>
<span class="c1">//to start from height and width</span>
<span class="c1">//and subtract. I choose to add.</span>

    <span class="kd">var</span> <span class="nx">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nx">fishCatch</span> <span class="o">=</span> <span class="p">[],</span>
      <span class="nx">height</span> <span class="o">=</span> <span class="nx">matrix</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">width</span> <span class="o">=</span> <span class="nx">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">//recursive function that carves a path</span>
<span class="c1">//through the matrix</span>

    <span class="kd">function</span> <span class="nx">travel</span><span class="p">(</span><span class="nx">matrix</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">total</span><span class="p">)</span> <span class="p">{</span>

<span class="c1">//boundary conditions</span>
<span class="c1">//if at a value the matrix doesn&#39;t see, return no fish.</span>
<span class="c1">//if at [2,2], send the total to be stored.</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&gt;</span> <span class="nx">width</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">&gt;</span> <span class="nx">height</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">width</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">===</span> <span class="nx">height</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">fishCatch</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">total</span> <span class="o">+</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">]);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

<span class="c1">//here&#39;s a very tricky part of it, you return moving in both directions.</span>
<span class="c1">//recursion will purse each path until it&#39;s logical conclusion,</span>
<span class="c1">//ASSUMING you set good boundaries.</span>

        <span class="k">return</span> <span class="nx">travel</span><span class="p">(</span><span class="nx">matrix</span><span class="p">,</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">total</span> <span class="o">+</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">])</span> <span class="o">+</span> <span class="nx">travel</span><span class="p">(</span><span class="nx">matrix</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">total</span> <span class="o">+</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">]);</span>
    <span class="p">}</span>

<span class="c1">//call the function. You can do this with an IFFY but those</span>
<span class="c1">//seem less legible to me.</span>

    <span class="nx">travel</span><span class="p">(</span><span class="nx">matrix</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">total</span><span class="p">);</span>

<span class="c1">//at this point, I have all the answers stored.</span>
<span class="c1">//if the matrix was 1 million x 1 million, we would probably</span>
<span class="c1">//overwrite with a max. I&#39;ll show you an example of this next.</span>
<span class="c1">//here we will just Math.max.apply to get the best catch.</span>

    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span><span class="nx">fishCatch</span><span class="p">);</span>
<span class="c1">// allTotals:[ 10, 19, 18, -&gt;( 21 )&lt;-, 20, 13 ]</span>
<span class="p">}</span>
</code></pre></div>
<p>If the tree is helpful, here&#39;s another look at what&#39;s happening.</p>

<p><img src="pondChoice.png" alt="alt view of pond problem"></p>

<p>And you&#39;ll see twists on this generic idea of a problem. This is something computers can do so quickly for us that was very hard to set out to solve before computers.</p>

<h3>The Life Total Problem</h3>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="cm">/*====================================||</span>
<span class="cm">|| Life Total                         ||</span>
<span class="cm">||                                    ||</span>
<span class="cm">|| In this problem you will travel    ||</span>
<span class="cm">|| through all possible paths through ||</span>
<span class="cm">|| a field gaining and losing health  ||</span>
<span class="cm">|| Start at the top left corner and   ||</span>
<span class="cm">|| go only one space at a time either ||</span>
<span class="cm">|| right or down until you reach the  ||</span>
<span class="cm">|| right bottom corner [2,2] for a    ||</span>
<span class="cm">|| 3 x 3 matrix. Find out what is the ||</span>
<span class="cm">|| minimum starting health you need   ||</span>
<span class="cm">|| get through the field alive!       ||</span>
<span class="cm">||====================================*/</span>

<span class="kd">var</span> <span class="nx">field</span> <span class="o">=</span>
<span class="p">[</span>
  <span class="p">[</span><span class="mi">0</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="o">-</span><span class="mi">3</span> <span class="p">],</span>
  <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span> <span class="p">],</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span>  <span class="o">-</span><span class="mi">5</span><span class="p">,</span>  <span class="mi">2</span> <span class="p">]</span>
<span class="p">];</span>
</code></pre></div>
<p>What&#39;s the major difference here? We have negative values, but fundamentally we need to keep track of only two numbers, the life total we have at each path, and an minimum extrema. The lowest point at which we have health will help us set our minimum health to stay alive.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">minLifeNeededToLive</span><span class="p">(</span><span class="nx">matrix</span><span class="p">)</span> <span class="p">{</span>

<span class="c1">//boundary variables as before</span>
<span class="c1">//major difference is there is no</span>
<span class="c1">//array, and a single maxHurt variable</span>
<span class="c1">//takes it&#39;s place. We could have done</span>
<span class="c1">//the same above, but I wanted to demonstrate</span>
<span class="c1">//the tree of decisions clearly.</span>

    <span class="kd">var</span> <span class="nx">lifeTotal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nx">maxHurt</span> <span class="o">=</span> <span class="kc">Infinity</span><span class="p">,</span>
      <span class="nx">height</span> <span class="o">=</span> <span class="nx">matrix</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">width</span> <span class="o">=</span> <span class="nx">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">//recursively travel as before. Modify your life total</span>
<span class="c1">//then ask at each point if the</span>

    <span class="kd">function</span> <span class="nx">travel</span><span class="p">(</span><span class="nx">matrix</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">lifeTotal</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&gt;</span> <span class="nx">width</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">&gt;</span> <span class="nx">height</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">//remember to add the life at [2,2] to the maxHurt check</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">lifeTotal</span> <span class="o">+</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">maxHurt</span><span class="p">)</span> <span class="p">{</span> <span class="nx">maxHurt</span> <span class="o">=</span> <span class="nx">lifeTotal</span> <span class="o">+</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">];</span> <span class="p">}</span>

<span class="c1">//stop the bloodshead!. a third boundary condition on [2,2]</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">width</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">===</span> <span class="nx">height</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">//travelling, just as before.</span>
<span class="c1">//passing this times life total to the next battle.</span>

        <span class="k">return</span> <span class="nx">travel</span><span class="p">(</span><span class="nx">matrix</span><span class="p">,</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">lifeTotal</span> <span class="o">+</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">])</span> <span class="o">+</span> <span class="nx">travel</span><span class="p">(</span><span class="nx">matrix</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">lifeTotal</span> <span class="o">+</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">]);</span>
    <span class="p">}</span>

<span class="c1">//run the function itself.</span>

    <span class="nx">travel</span><span class="p">(</span><span class="nx">matrix</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">lifeTotal</span><span class="p">);</span>

<span class="c1">//the final calculations. To stay alive, I need to survive the lowest point in my health, i.e. 1 - maxHurt taken.</span>

    <span class="k">return</span> <span class="o">-</span><span class="nx">maxHurt</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// minimal health</span>
<span class="p">}</span>
</code></pre></div>
<p>Hopefully that is helpful! I&#39;m going to skip making the tree this time if that works with you.</p>

<h3>The Islands and Ponds Problem</h3>

<p>Another similar and slightly more complicated problem is islands and ponds. This matrix requires you to either keep track on information upon examination and traverse within your traversal. To be clear, the example below shows two ponds (ones), within a set of land (zeros).</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">maps</span> <span class="o">=</span> <span class="p">[</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">];</span>
</code></pre></div>
<p>When each pond is discovered, we need to travel horizontally and vertically to verify that this is not a new pond. One method might be to change the pond found in an iterative loop, so that when the first pond checker lands on the spot again, they find that a change has been made (logically, to zero). --&gt;</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">//process:[x][y], subprocess:0</span>
<span class="kd">var</span> <span class="nx">maps</span> <span class="o">=</span> <span class="p">[</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,((</span><span class="mi">1</span><span class="p">)),</span><span class="mi">0</span><span class="p">],</span>  <span class="c1">// on this spot</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">];</span>

<span class="c1">//subprocess:1</span>
<span class="kd">var</span> <span class="nx">maps</span> <span class="o">=</span> <span class="p">[</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>  <span class="c1">// on this spot</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,((</span><span class="mi">1</span><span class="p">)),</span><span class="mi">1</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">];</span>

<span class="c1">//subprocess:2</span>
<span class="kd">var</span> <span class="nx">maps</span> <span class="o">=</span> <span class="p">[</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>  <span class="c1">//  move down</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,((</span><span class="mi">0</span><span class="p">)),</span><span class="mi">1</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">];</span>

<span class="c1">//subprocess:3</span>
<span class="kd">var</span> <span class="nx">maps</span> <span class="o">=</span> <span class="p">[</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>  <span class="c1">// change one to</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,((</span><span class="mi">0</span><span class="p">)),</span><span class="mi">1</span><span class="p">],</span> <span class="c1">//zero</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">];</span>

<span class="c1">//subprocess:4</span>
<span class="kd">var</span> <span class="nx">maps</span> <span class="o">=</span> <span class="p">[</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>  <span class="c1">// finish</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,((</span><span class="mi">1</span><span class="p">))],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,((</span><span class="mi">1</span><span class="p">)),</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">];</span>

<span class="c1">//subprocess:5</span>
<span class="kd">var</span> <span class="nx">maps</span> <span class="o">=</span> <span class="p">[</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>  <span class="c1">// no where else</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,((</span><span class="mi">0</span><span class="p">))],</span> <span class="c1">// to go</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,((</span><span class="mi">0</span><span class="p">)),</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">];</span>

<span class="c1">//resume process [x][y+1]</span>
<span class="kd">var</span> <span class="nx">maps</span> <span class="o">=</span> <span class="p">[</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="c1">// and avoid</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="c1">// double counting</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">];</span>
</code></pre></div>
<p>So, to solve this problem, I decided to use a stack, and inside the stack there was an object indicating exactly what part of the matrix I was on at any given time, and then each &quot;1&quot; found in this sub process was converted to a &quot;0&quot; to avoid in being counting again. When this process completed, and only then, did the actual pond counter increment. So after all the processes above, we return to the problem and then resume looking around.</p>

<p>Islands and Ponds Problem</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="cm">/*====================================||</span>
<span class="cm">|| Islands and Ponds                  ||</span>
<span class="cm">||                                    ||</span>
<span class="cm">|| Count the number of ponds in a     ||</span>
<span class="cm">|| matrix.                            ||</span>
<span class="cm">||====================================*/</span>
<span class="c1">// map needs to be a matrix format</span>
<span class="kd">var</span> <span class="nx">map</span> <span class="o">=</span> <span class="p">[</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">];</span>

<span class="kd">var</span> <span class="nx">numPonds</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">grid</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// provided a grid, we create this</span>
<span class="c1">// iterative varibles here</span>
  <span class="kd">var</span> <span class="nx">top</span><span class="p">,</span> <span class="nx">split</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">;</span>

<span class="c1">// We need a recursive loop</span>
<span class="c1">// as always. This is the subprocess</span>
<span class="c1">// from above.</span>
  <span class="kd">function</span> <span class="nx">expanse</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// we take our input and look at the values there.</span>
      <span class="nx">top</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
      <span class="nx">i</span> <span class="o">=</span> <span class="nx">top</span><span class="p">.</span><span class="nx">row</span><span class="p">;</span>
      <span class="nx">j</span> <span class="o">=</span> <span class="nx">top</span><span class="p">.</span><span class="nx">col</span><span class="p">;</span>
<span class="c1">// If at that value, I have a &quot;1&quot;, change it to &quot;0&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// console.log(grid) if you want to see changes.</span>
<span class="c1">// you can also copy the grid if you don&#39;t want</span>
<span class="c1">// to modify the original object.</span>

<span class="c1">// Here we are travelling to the other areas and</span>
<span class="c1">// documenting them as a stack</span>
<span class="c1">// you can also use a while loop but this is</span>
<span class="c1">// a better way to keeping track of your info.</span>
          <span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="nx">row</span><span class="o">:</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">,</span> <span class="nx">col</span><span class="o">:</span> <span class="nx">j</span><span class="p">});</span>
          <span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="nx">row</span><span class="o">:</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">,</span> <span class="nx">col</span><span class="o">:</span> <span class="nx">j</span><span class="p">});</span>
          <span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="nx">row</span><span class="o">:</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">col</span><span class="o">:</span> <span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">});</span>
          <span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="nx">row</span><span class="o">:</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">col</span><span class="o">:</span> <span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">});</span>
        <span class="p">}</span>
<span class="c1">// This keeps us processing everything.        </span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">expanse</span><span class="p">(</span><span class="nx">stack</span><span class="p">);</span> <span class="p">}</span>
      <span class="p">}</span>
<span class="c1">// This is the process from above.</span>
<span class="c1">// We travel to each square and make ad decision.</span>
<span class="c1">// There are optimizations for double counting</span>
<span class="c1">// that I&#39;m not going to talk about here.</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">grid</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">N</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">x</span> <span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
      <span class="nx">N</span> <span class="o">=</span> <span class="nx">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">length</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">N</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">grid</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
<span class="c1">// If I have a pond, trigger subprocess</span>
            <span class="nx">expanse</span><span class="p">([{</span><span class="s2">&quot;row&quot;</span><span class="o">:</span> <span class="nx">x</span><span class="p">,</span> <span class="s2">&quot;col&quot;</span><span class="o">:</span> <span class="nx">y</span><span class="p">}]);</span>
<span class="c1">// And when the process is truly done</span>
<span class="c1">// and I&#39;m not at risk of double counting</span>
<span class="c1">// any ponds, increment the pond counter</span>
              <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">count</span><span class="p">;</span>
 <span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">numPonds</span><span class="p">(</span><span class="nx">map</span><span class="p">));</span>

<span class="c1">//See the changed map, always completely zeroes.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">map</span><span class="p">);</span>
</code></pre></div>
<h3>Robot Paths</h3>

<p>To follow this same set of logic, a duplicate board or a board that simply has true or false at each position can help us keep track of what has been seen or what has not been seen. This solver is an essential part of most of our games and their automatic moves and solvers. The last thing I&#39;m going to blog about here is an approach where you move in all directions at all times, and the duplicate true false board will play a big role in deciding what can happen next.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="cm">/*====================================||</span>
<span class="cm">|| Fishing Trip                       ||</span>
<span class="cm">||                                    ||</span>
<span class="cm">|| You are located at the top left    ||</span>
<span class="cm">|| corner of a 5x5 grid is trying to  ||</span>
<span class="cm">|| reach the bottom right       .     ||</span>
<span class="cm">|| You can move either up, down,      ||</span>
<span class="cm">|| left, or right, but cannot visit   ||</span>
<span class="cm">|| the same spot twice. How many      ||</span>
<span class="cm">|| possible unique paths are there    ||</span>
<span class="cm">|| to the bottom right?               ||</span>
<span class="cm">||====================================*/</span>
</code></pre></div>
<p>Our first step is to make that &quot;already visited&quot; board.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">Board</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>

  <span class="kd">var</span> <span class="nx">board</span> <span class="o">=</span> <span class="p">[],</span>
    <span class="nx">i</span><span class="p">,</span>
    <span class="nx">j</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">board</span><span class="p">.</span><span class="nx">push</span><span class="p">([]);</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">board</span><span class="p">.</span><span class="nx">togglePiece</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">!</span><span class="k">this</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="nx">board</span><span class="p">.</span><span class="nx">hasBeenVisited</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">!!</span><span class="k">this</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">board</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>As before, we will make a recursive function that will move everywhere.
It&#39;s pretty much indentical to our previous approaches except to prevent
you from going where you&#39;ve been before you need to see the board.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">countAllPaths</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">board</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>

<span class="c1">//Create the board if none exists.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">board</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">board</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Board</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
    <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

<span class="c1">// If you go off the board or</span>
<span class="c1">// somewhere you&#39;ve been, exit.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">i</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">)</span> <span class="o">||</span> <span class="nx">board</span><span class="p">.</span><span class="nx">hasBeenVisited</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

<span class="c1">// If you reach the end, return 1</span>
<span class="c1">// so that it can be added up for</span>
<span class="c1">// the final answer</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="o">===</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// toggling is a hard concept</span>
<span class="c1">// but it is the process of undoing the</span>
<span class="c1">// most recent move</span>
  <span class="nx">board</span><span class="p">.</span><span class="nx">togglePiece</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">);</span>

<span class="c1">// Start calculating the number of paths</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">countAllPaths</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">board</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span>
    <span class="nx">countAllPaths</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">board</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span>
    <span class="nx">countAllPaths</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">board</span><span class="p">,</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span> <span class="o">+</span>
    <span class="nx">countAllPaths</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">board</span><span class="p">,</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="p">);</span>
<span class="c1">// This is a way to preventing</span>
<span class="c1">// Infinite loops for empty calculations</span>
  <span class="nx">board</span><span class="p">.</span><span class="nx">togglePiece</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">);</span>
<span class="c1">// This gives us our final big number.</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>

<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">countAllPaths</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
</code></pre></div>
<p>These stumped me live, but after some time to think about it, I&#39;ll be ready for the next set of these, and I hope this helped you.</p>

<p><img src="manyPaths.png" alt="joke at the end."></p>

  </div>

  
<div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = "chrissalam";//'chrissalam';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>


</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          
<a href="mailto:christopher.salam@gmail.com"><i class="svg-icon email"></i></a>
<a href="https://www.facebook.com/mrsalam@ucdavis.edu"><i class="svg-icon facebook"></i></a>

<a href="https://github.com/ChristopherSalam"><i class="svg-icon github"></i></a>

<a href="https://www.linkedin.com/in/christophersalam"><i class="svg-icon linkedin"></i></a>






        </footer>
      </div>
    </div>
    
	<!-- Google Analytics -->
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-65733928-2', 'auto');
		ga('send', 'pageview', {
		  'page': '/matrix-paths/',
		  'title': 'matrix paths'
		});
	</script>
	<!-- End Google Analytics -->


  </body>
</html>
