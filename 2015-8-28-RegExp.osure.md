---
layout: post
title: /n complexity
tags:
- regexp
- js
---

I wanted to start off by saying succinctly and firmly that I believe using regular expressions are often more time complex, certainly less intuitive, and often only effective for niche situations when it comes to solving coding challenges and interview questions... however, I am still fascinated with it!

A time complexity optimized solution refers to having the fewest amount of operations.
A space complexity optimized solution refers to having the fewest amount of stored information.
RegExp solutions offer a chance at <a href="https://en.wikipedia.org/wiki/Computational_complexity_theory">computational complexity</a>, albeit an artificial kind. It's like fighting with an exotic weapon or wrestling left handed, the challenge is extra enticing.

The fourth, and most magical and completely illusionary goal is newline complexity, or /n complexity which is something I made up, to address the goal of every RegExp purist --> to solve the problem in as few lines as possible, no matter all the other complexities. The pursuit of the **regexp one-liner** as an answer is the holy grail of these often fruitless pursuits.

Here are some explanations of my recent approaches to some of our short problems which I would **never attempt during an interview**.

<center>**First Non-repeated Character**</center>

```javascript
var firstNonRepeatedCharacter = function (string) {
  var i;
  for (i = 0; i < string.length; i++) {
    if (string.match(new RegExp(string[i], 'g')).length === 1) {
      return string[i];
    }
  } return "none";
};

//Test Suite
firstNonRepeatedCharacter = function('aabcc');
                  // --> 'b'
firstNonRepeatedCharacter = function('aabc');
                  // --> 'b'
firstNonRepeatedCharacter = function('aacc');
                  // --> 'none'
```

A simple iterative for loop solution would have addressed this within linear complexity.

<center>**Common Characters**</center>

Write a function `f(a, b)` which takes two strings as arguments and returns a string containing the characters found in both strings (without duplication), in the order that they appeared in `a`. Remember to skip spaces and characters you have already encountered! Extra credit: Extend your function to handle more than two input strings.

```javascript
var commonCharacters = function (string1) {

  var string1Chars = {}, strNoDups = "", regExp, i, j;

  string1.split("").forEach(function (element) { string1Chars[element] = true; });
  for (i in string1Chars) { if (i) {strNoDups += i; } }

  for (j = 1; j < arguments.length; j++) {
    regExp = new RegExp('[' + arguments[j] + ']', 'g');
    strNoDups = strNoDups.match(regExp).join("");
  }
  return strNoDups;
};

//Test Suite
console.log(commonCharacters('aceexivoue', 'aegihobue'));
                  // --> 'aeiou'
console.log(commonCharacters('aecexivou', 'aegihobu', 'aeefilou'));
                  // --> 'aeiou'
console.log(commonCharacters('dcba', 'abcd'));
                  // --> 'dcba'

```
First variables are declared. Next an involved step must be taken to remove the duplicates from the base case string. String1 may have duplicate characters in it, and we must travel through the string to remove them. I am not aware of a less newline complex regexp to solve this particular part of the problem, so I used forEach. After that, we regExp each other string through the base case string to filter out what we want.

```javascript
var longestRun = function (string) {
  var length,
    targetIndex = null;
  for (var i = 0; i < string.length; i++) {
    var reg = new RegExp(string[i]+ '{2,}')
    if (string.match(reg)) {
      length = string.match(reg)[0].length - 1;
      targetIndex = string.match(reg).index + 1;
    };
  }
  return (targetIndex === null) ? [0, 0] : [targetIndex, targetIndex + length];
};
```

```javascript
var longestRun = function (string) {
  var theRun = string.match(/([a-zA-Z])\1{1,}/);
  return (theRun === null) ? [0, 0] : [ theRun.index, theRun[0].length ];
};
```